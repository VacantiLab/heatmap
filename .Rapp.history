source("/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts_dev_parallel/BaselineCorrect.R")#
source("/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts_dev_parallel/GetDerivs.R")#
source("/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts_dev_parallel/FindPeakBorders.R")#
source("/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts_dev_parallel/fat_matrix_to_long_df.R")#
source("/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts_dev_parallel/FindPeaksMins.R")#
#
t_start_script <- proc.time()[3]#
#
#load libraries necessary for function to run#
library(ncdf4) #needed to open NetCDF files containing MS data, ncdf4 package#
library(ggplot2) #needed to make plots#
#
#specify what is to be plotted#
XData <- 'sat'#
YData <- 'intensity'#
mz_select <- c(174,175,176)#
#
#open the data file#
print('unpacking data')#
NetCDF_data <- nc_open('/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Tools/R Functions/NetCDF_Integrate_Scripts/Test_NetCDF_Files/T47D_no_label.AIA/tbdms01_t47d_wt.CDF')#
#
#extract m/z values needed#
mass_values <- ncvar_get(NetCDF_data,'mass_values') #unpack the NetCDF file#
  #these values are one large vector, the m/z values of each scan are concatonated together#
mass_values_whole <- round(mass_values)#
  #these are rounded to the nearest whole number value because tracing experiments are only concerned with whole number increments#
  #note: the charge is always +1, so m/z is really the mass#
mz_whole_unique <- unique(mass_values_whole)#
mz_whole_unique <- sort(mz_whole_unique,decreasing=FALSE)#
  #the unique masses are needed for organizing the masses, the time of scans, and the intensities#
  #they are organized in ascending order for better visualization#
n_mz <- length(mz_whole_unique) #the number of unique m/z values (after rounding)#
#
#unpack the vector containing the time each scan was made#
scan_acquisition_time <- ncvar_get(NetCDF_data,'scan_acquisition_time')/60 #minutes#
n_sat <- length(scan_acquisition_time) #the number of scan acqisitions#
#
#these are the ion counts for each m/z measurement in each scan#
#the order corresponds to the mass_values vector described above#
intensity_values <- ncvar_get(NetCDF_data,'intensity_values')#
n_total_measurements <- length(intensity_values)#
#
#the scan indices provide the location within the mass_values and intensity_values vectors where a new scan starts#
#a scan index is one index value prior to the location where a new scan starts#
scan_index <- ncvar_get(NetCDF_data,'scan_index')#
n_scans <- length(scan_index)#
#
#Ion Count Matrix#
#initialize a matrix that will contain the scan acquisition times across the columns and the m/z values down the rows#
#the matrix will be filled with corresponding ion count values#
mz_time_intensity <- matrix(,nrow=n_mz,ncol=n_sat)#
rownames(mz_time_intensity) <- mz_whole_unique#
colnames(mz_time_intensity) <- scan_acquisition_time#
#
#populate mz_time_intensity matrix#
for (i in 1:n_scans)#
{#
  current_scan_start <- scan_index[i]+1#
  if (i!=n_scans) {current_scan_end <- scan_index[i+1]}#
  if (i==n_scans) {current_scan_end <- n_total_measurements}#
  sat_value_current_scan <- as.character(scan_acquisition_time[i]) #the current column in mz_time_intensity to be populated#
  mzs_of_current_scan <- as.character(mass_values_whole[current_scan_start:current_scan_end]) #the mz values measured in the current scan, the rows to be populated in the mz_time_intensity matrix#
  intensity_values_current_scan <- intensity_values[current_scan_start:current_scan_end]#
  mz_time_intensity[mzs_of_current_scan,sat_value_current_scan] <- intensity_values_current_scan #fill in the desired rows (corresponding to measured m/z's) in the desired column (corresponding to the current scan acquisition time)#
}#
#
#Baseline Corrected Intensity Matrix Initialization#
#initialize a matrix that will contain the scan acquisition times across the columns and the m/z values down the rows#
#the matrix will be filled with corresponding baseline corrected ion count values#
mz_time_intensity_baseline_corrected <- matrix(,nrow=n_mz,ncol=n_sat)#
rownames(mz_time_intensity_baseline_corrected) <- mz_whole_unique#
colnames(mz_time_intensity_baseline_corrected) <- scan_acquisition_time#
#
#Baseline Correction Values Matrix Initialization#
#initialize a matrix that will contain the scan acquisition times across the columns and the baseline m/z values down the rows#
#the matrix will be filled with corresponding baseline ion count values#
baseline_correction <- matrix(,nrow=n_mz,ncol=n_sat)#
rownames(baseline_correction) <- mz_whole_unique#
colnames(baseline_correction) <- scan_acquisition_time#
#
#Fill in both Baseline Matrices#
print('finding baselines')#
#correct the mz_time_intensity matrix for baseline#
#install.packages("doMC")#
require(doMC)#
registerDoMC(4)#
t_start_script <- proc.time()[3]#
BaselineCorrect_return <- apply(mz_time_intensity,1,BaselineCorrect,scan_acquisition_time,2)#
t_elapsed_script <- (proc.time()[3]-t_start_script)
t_elapsed_script
setwd('/Users/Nate/git_hub_projects/heatmap')
data_location<-'/Users/Nate/Dropbox/Research/Lehtio_Laboratory/Projects/breast_cancer/cell_lines/Protein_Quantification_Data/'
select_groups <- list(c('basal a','basal b'),c('luminal'))
vp <- MakeVolcanoPlot(data_location,'PAM50',NULL,NULL,NULL,select_groups,'cell_type','oxidative_phosphorylation_kegg.txt')
source('initialize_heatmap.R')
vp <- MakeVolcanoPlot(data_location,'PAM50',NULL,NULL,NULL,select_groups,'cell_type','oxidative_phosphorylation_kegg.txt')
source('initialize_heatmap.R')
vp <- MakeVolcanoPlot(data_location,'PAM50',NULL,NULL,NULL,select_groups,'cell_type','oxidative_phosphorylation_kegg.txt')
source('initialize_heatmap.R')
vp <- MakeVolcanoPlot(data_location,'PAM50',NULL,NULL,NULL,select_groups,'cell_type','oxidative_phosphorylation_kegg.txt')
bp <- MakeBoxPlot(data_location,'PAM50','log2',NULL,c('TYMS','PDK1','PDK2','PDK3'),select_groups,'cell_type')
source('initialize_heatmap.R')
bp <- MakeBoxPlot(data_location,'PAM50','log2',NULL,c('TYMS','PDK1','PDK2','PDK3'),select_groups,'cell_type')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.d2','NULL','NULL','select_groups',FALSE,TRUE,FALSE)
select_groups
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.d2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
traceback()
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
DATA[1:5,1:5]
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
DATA[1:5,1:5]
Q
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
DATA[1:5,1:5]
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
data
select_rows
DATA <- OpenDataFile(data,select_rows)
DATA[1:5,1:5]
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
txt_directory
DF <- read.table(file=txt_directory,head=TRUE,check.names=FALSE,sep='\t')
DF[1:5,1:5]
RowNames <- as.character(DF[,1])
RowNames[1:5]
rownames(DF) <- RowNames
RowNames[1:5]
DF[1:5,1:5]
DF[,1] <- NULL
DF[1:5,1:5]
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2','NULL','NULL',select_groups,FALSE,TRUE,FALSE)
DATA[1:5,1:5]
has_no_na_row_indices <- apply(DATA,1,NoNA)
length(has_no_na_indices)
length(has_no_na_row_indices)
DATA <- DATA[has_no_na_row_indices,]
DATA[1:5,1:5]
length(DATA[,1])
sum(has_no_na_row_indices)
select_rows
!is.null(select_rows)
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
hm
TRUE | FALSE
TRUE || FALSE
c(TRUE TRUE) | c(TRUE FALSE)
c(TRUE TRUE)
c(TRUE, TRUE) | c(TRUE, FALSE)
c(TRUE, TRUE) || c(TRUE, FALSE)
source('initialize_heatmap.R')
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
visualization=='boxplot' | visualization=='volcanoplot'
visualization=='boxplot' | visualization=='volcanoplot'
Q
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
sit_test_list
sig_test_list
FillColors
group_order
Q
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
hm <- MakeHeatMap(data_location,'cell_type','log2',seq(-2,2,0.5),NULL,'pearson','ward.D2',NULL,NULL,NULL,FALSE,TRUE,FALSE)
source('initialize_heatmap.R')
hm <- MakeHeatMap(data_location,'PAM50','log2',seq(-2,2,0.5),'cell_type','pearson','ward.D2',NULL,NULL,select_groups,FALSE,TRUE,FALSE)
vp <- MakeVolcanoPlot(data_location,'PAM50',NULL,NULL,NULL,select_groups,'cell_type','oxidative_phosphorylation_kegg.txt')
bp <- MakeBoxPlot(data_location,'PAM50','log2',NULL,c('TYMS','PDK1','PDK2','PDK3'),select_groups,'cell_type')
